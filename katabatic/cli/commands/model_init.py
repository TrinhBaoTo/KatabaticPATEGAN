import os
import re
from pathlib import Path
from typing import List, Optional, Tuple


def _find_models_dict_bounds(text: str) -> Tuple[int, int, str]:
    """
    Return (open_brace_idx, close_brace_idx, indent) for the _models dict.
    Uses brace counting and skips over strings.
    """
    m = re.search(r"_models\s*:\s*Dict\[[^\]]*\]\s*=\s*{", text)
    if not m:
        m = re.search(r"_models\s*=\s*{", text)
    if not m:
        raise ValueError("Could not find `_models = { ... }` in registry.py")

    open_idx = text.find("{", m.start())
    if open_idx == -1:
        raise ValueError("Could not find opening `{` for _models dictionary")

    line_start = text.rfind("\n", 0, open_idx) + 1
    indent = re.match(r"[ \t]*", text[line_start:open_idx]).group(0)

    depth = 0
    i = open_idx
    in_str: Optional[str] = None
    escaped = False
    while i < len(text):
        ch = text[i]
        if in_str:
            if escaped:
                escaped = False
            elif ch == "\\":
                escaped = True
            elif ch == in_str:
                in_str = None
        else:
            if ch in ("'", '"'):
                in_str = ch
            elif ch == "{":
                depth += 1
            elif ch == "}":
                depth -= 1
                if depth == 0:
                    return open_idx, i, indent
        i += 1

    raise ValueError("Unbalanced braces in _models dictionary")


def _serialize_list_str(xs: List[str]) -> str:
    return "[" + ", ".join(repr(s) for s in xs) + "]"


def init_model(model_name: str, dependencies: Optional[List[str]] = None) -> None:
    """Initialize a new model structure aligned with the base `Model` API.

    Args:
        model_name: Name of the model to create (e.g. "Rlig" or "rlig")
        dependencies: Optional list of Python package dependencies for the model.
                      These will be embedded in the subclass' get_required_dependencies().
    """
    dir_name = re.sub(r"(?<!^)(?=[A-Z])", "_", model_name).lower()
    if not re.fullmatch(r"[a-z][a-z0-9_]*", dir_name):
        raise ValueError(
            "Invalid model name. Use letters, numbers and underscores; start with a letter.")
    class_name = "".join(word.capitalize() for word in dir_name.split("_"))

    from katabatic.models.registry import ModelRegistry

    models_dir = Path(__file__).parents[2] / "models"
    new_model_dir = models_dir / dir_name

    if new_model_dir.exists():
        raise ValueError(f"Model directory {dir_name} already exists")

    if dir_name in ModelRegistry.get_available_models():
        raise ValueError(f"Model {dir_name} is already registered")

    new_model_dir.mkdir(parents=True)

    # __init__.py
    (new_model_dir / "__init__.py").write_text(
        f'''"""Module for {class_name} model."""
from .models import {class_name}

__all__ = ["{class_name}"]
'''
    )

    deps = dependencies or []

    (new_model_dir / "models.py").write_text(
        f'''"""Implementation of {class_name} model."""
from typing import Any, Union
import numpy as np
import pandas as pd

from katabatic.models.base_model import Model
from . import utils as _utils


class {class_name}(Model):
    """Implementation of {class_name} model."""

    def __init__(self):
        super().__init__()
        # Validate runtime dependencies early to fail fast
        self.check_dependencies()

    @classmethod
    def get_required_dependencies(cls) -> list[str]:
        # Generated by init_model; adjust as your model evolves.
        return {deps!r}

    def train(self, *args, **kwargs) -> "Model":
        \"\"\"Train the model on the given data.\"\"\"
        raise NotImplementedError

    def evaluate(self, *args, **kwargs) -> float:
        \"\"\"Evaluate the model performance and return a score.\"\"\"
        raise NotImplementedError

    def sample(self, *args, **kwargs) -> Union[np.ndarray, pd.DataFrame]:
        \"\"\"Generate synthetic samples.\"\"\"
        raise NotImplementedError
'''
    )

    (new_model_dir / "utils.py").write_text(
        f'''"""Utility functions for {class_name} model."""

# Add your utility functions here.
'''
    )

    registry_path = models_dir / "registry.py"
    registry_content = registry_path.read_text()

    open_idx, close_idx, indent = _find_models_dict_bounds(registry_content)

    entry_indent = indent + "    "
    new_entry = (
        f"{entry_indent}'{dir_name}': {{\n"
        f"{entry_indent}    'module': 'katabatic.models.{dir_name}.models',\n"
        f"{entry_indent}    'class': '{class_name}',\n"
        f"{entry_indent}    'dependencies': {_serialize_list_str(deps)},\n"
        f"{entry_indent}    'extra': '{dir_name}'\n"
        f"{entry_indent}}}"
    )

    before = registry_content[:close_idx].rstrip()
    after = registry_content[close_idx:]

    needs_comma = not before.endswith("{")
    if needs_comma and not before.endswith(","):
        before = before + ","

    if not before.endswith("\n"):
        before = before + "\n"

    new_registry = before + new_entry + "\n" + after

    registry_path.write_text(new_registry)

    scripts_dir = Path(__file__).parents[3] / "scripts"
    scripts_dir.mkdir(parents=True, exist_ok=True)
    setup_script_path = scripts_dir / f"setup_{dir_name}.sh"
    setup_script_path.write_text(
        f"""#!/bin/bash
# Setup script for {class_name} model dependencies

pip install katabatic[{dir_name}]
"""
    )
    os.chmod(setup_script_path, 0o755)

    print(f"""Successfully:
1. Created {class_name} model structure in {new_model_dir}
2. Added model to registry
3. Created setup script at {setup_script_path}

Next steps:
1. Add your model's dependencies to pyproject.toml in:
   - [tool.poetry.dependencies] (as optional = true)
   - [tool.poetry.extras] {dir_name} = [...]
2. Implement train/evaluate/sample in {new_model_dir}/models.py
3. Add any utility functions in {new_model_dir}/utils.py""")
